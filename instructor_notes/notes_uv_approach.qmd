---
title: "Lesson Plan - Teaching uv approach to installing Python"
author: "Jeremy Mikecz
institute: "Research Faciliation, Dartmouth Libraries"
date: "Jan 13, 2026"
format: html
editor: visual
---

# PART 1: WORKSHOP LESSON PLAN (2 Hours)

## Workshop Overview

**Target Audience:** Graduate students, postdocs, faculty, and staff (beginner to intermediate Python users)\
**Duration:** 2 hours\
**Format:** Hands-on workshop with live coding demonstrations\
**Tools:** Visual Studio Code, uv, Python, Git

## Pre-Workshop Checklist for Instructors

**Technical Prep:**

-   Test installation sequence on Windows, Mac, and Linux

-   Prepare sample project repository on GitHub

-   Create sample data files (CSVs, text files)

-   Set up backup cloud environment (Google Colab or GitHub Codespaces)

-   Test projector/screen sharing with VS Code visible

**Materials:**

-   Slides for intro sections

-   Printed quick reference cards

-   WiFi password visible

-   Helper contact info for troubleshooting

**Sample Repository Structure to Create Before Workshop:**

```         
python-workshop-sample/
├── data/
│   ├── raw/
│   │   ├── survey-responses.csv
│   │   ├── experiment-1.csv
│   │   ├── experiment-2.csv
│   │   ├── text-sample-1.txt
│   │   └── text-sample-2.txt
│   └── processed/
├── scripts/
│   ├── process-data.py
│   └── text-analysis.py
├── notebooks/
│   └── data-analysis.ipynb
├── results/
│   ├── figures/
│   └── tables/
├── .gitignore
├── README.md
└── pyproject.toml
```

## Timeline & Activities

### **INTRODUCTION (15 minutes)**

#### **Activity 1: Welcome & Context Setting (10 minutes)**

**Instructor Script:**

"Welcome everyone! I'm excited to have you here. Today we're covering something that might seem basic but is actually one of the most important skills for research computing: setting up Python properly and following best practices from day one.

Before we touch a computer, let's talk about the 'why' behind what we're doing.

**Why Program? Why Program in a World of AI?**

Let me start with a question: How many of you have used ChatGPT, Claude, or GitHub Copilot to help with code?"

*\[Show of hands, acknowledge responses\]*

"These AI tools are revolutionary, but here's what I want you to understand: They're powerful assistants, not replacements for understanding code. Here's why you still need programming skills:

1.  **Verification**: AI makes mistakes. You need to read and understand code to catch errors. I've seen ChatGPT confidently give me broken code that looks plausible.

2.  **Debugging**: When AI-generated code doesn't work (and it often doesn't on the first try), YOU need to debug it. No AI can debug your specific research problem without your domain knowledge.

3.  **Computational Thinking**: Breaking complex research questions into logical steps—this is the heart of programming and AI can't do this for you. You need to know what to ask for.

4.  **Control and Transparency**: When you write code, you know EXACTLY what's happening to your data. Black-box AI tools? Not so much. For research integrity, this matters enormously.

5.  **Customization**: Your research is unique. AI gives you templates, but YOU need to adapt them to your specific needs.

6.  **Agency**: Programming gives you power over your entire research workflow. You're not dependent on expensive software licenses or limited tool features.

Think of it this way: AI is like having a very knowledgeable but sometimes unreliable research assistant. You're still the principal investigator who needs to understand and validate the work.

**Why Python Specifically?**

Great, so we need to program. Why Python?"

*\[Show slide with Python logo and statistics\]*

"1. **Dominance in Research**: Python is the most popular language in research computing. Look at any 'most popular languages' chart from the last 5 years—Python is always in the top 2.

2.  **Incredible Ecosystem**: Whatever your field, there's probably a Python package for it:

    -   Data analysis: pandas, numpy, scipy

    -   Visualization: matplotlib, seaborn, plotly

    -   Statistics: statsmodels, pingouin

    -   Machine learning: scikit-learn, tensorflow, pytorch

    -   Text analysis: nltk, spacy

    -   Network analysis: networkx

    -   Geographic data: geopandas

    -   And thousands more...

3.  **Readable Syntax**: Python is often called 'executable pseudocode.' Look at this comparison:"

*\[Show slide comparing Python to other languages\]*

"Compare that to Java or C++, and you'll see why beginners love Python.

4.  **Cross-Disciplinary**: Whether you're in biology, sociology, linguistics, physics, or digital humanities, Python is used in your field. This means great community support.

5.  **Free and Open Source**: No licenses, no restrictions. Use it for anything, anywhere.

6.  **Career Value**: Python skills are highly transferable. Industry, academia, government—everyone uses Python."

#### **Activity 2: The Setup Problem (5 minutes)**

**Instructor Script:**

"However, the problem is that Python setup is notoriously difficult. It's probably the single biggest barrier to learning Python.

Some common problems:

-   Code that worked on one computer but broke on another?

-   Confusion about pip vs conda vs virtualenv vs venv?

-   'Python is not recognized as a command' errors?

-   Breaking your Python installation by installing the wrong package?

-   Multiple Python versions fighting each other?

-   A tutorial that starts with 'just pip install' and it doesn't work?"

\[Python Set up approach slide\]

### **BEST PRACTICES OVERVIEW (15 minutes)**

#### **Activity 3: Research Coding Best Practices (15 minutes)**

**Instructor Script:**

"Before we install anything, I want to establish the principles we'll follow. These aren't optional extras—they're essential for reproducible, shareable research. If you learn Python without these practices, you'll have to unlearn bad habits later. Let's do it right from the start."

**1. Project Organization: One Project, One Folder**

*\[Show slide with folder structure\]*

**Instructor Script:**

"Every research project should live in its own folder with a consistent structure. Here's what I recommend:

**2. Naming Conventions**

*\[Show slide with good vs bad examples\]*

**Instructor Script:**

How you name files and folders matters more than you think.

## Virtual Environments

Think of these as isolated Python installations for each project. This prevents the 'it works on my machine' problem.

```         
Each project gets its own environment
Install only what you need for that project
Easy to recreate on another computer
uv makes this automatic!"
```

The Problem Without Virtual Environments:

Imagine you have two research projects:

```         
Project A (from 2022) needs pandas version 1.3
Project B (new project) needs pandas version 2.0
```

If you install both globally on your computer, they conflict. Project A breaks when you update pandas for Project B.

The Solution: Virtual Environments

Each project gets its own isolated Python environment:

```         
Project A has its own copy of pandas 1.3
Project B has its own copy of pandas 2.0
They never conflict!
```

Benefits:

```         
 Reproducibility: You can recreate the exact environment on another computer
 Safety: Can't break other projects by installing something
 Cleanliness: Only install what each project needs
 Collaboration: Others can easily set up the same environment
```

**4. Version Control with Git**

*\[Show slide with git concept visualization\]*

**Instructor Script:**

"Version control is like 'Track Changes' for code, but vastly more powerful.

**What Git Does:**

-   Tracks every change you make to your files

-   Lets you go back to any previous version

-   Shows you exactly what changed and when

-   Enables collaboration without emailing files back and forth

-   Provides backup (when used with GitHub/GitLab)

**Research Scenarios Where Git Saves You:**

*Scenario 1:* 'My analysis worked last week, but now it's broken. What changed?'\
→ Git shows you exactly what changed and lets you revert.

*Scenario 2:* 'I want to try a different analysis approach but don't want to lose my current code.'\
→ Git branches let you experiment safely.

*Scenario 3:* 'A collaborator needs to run my analysis.'\
→ They clone your repository and have everything.

*Scenario 4:* 'A reviewer asks about code from a paper I published a year ago.'\
→ Git preserves the exact version you used.

**Basic Git Workflow:**

```{bash}
git init                          # Initialize repository (once)
git add file.py                   # Stage changes
git commit -m "Add analysis"      # Save snapshot with message
git push                          # Upload to GitHub (for backup/sharing)
```

**Key Terms:**

-   **Repository (repo)**: Your project folder tracked by git

-   **Commit**: A snapshot of your project at a point in time

-   **Push**: Upload commits to GitHub/GitLab

-   **Pull**: Download commits from GitHub/GitLab

-   **Clone**: Download someone else's repository

We'll initialize git for every project today. You don't need to master git immediately, but starting with it builds good habits."

**5. Integrated Development Environments (IDEs)**

*\[Show slide with VS Code interface\]*

**Instructor Script:**

"An IDE is your coding workspace—where you write, run, and debug code.

**6. Documentation**

*\[Show slide with README example\]*

**Instructor Script:**

"Documentation is your project's instruction manual. The most important document is your README.md file.

Instructor Notes for This Approach

```         
Test the uv installation on a clean machine beforehand (VM or Docker container) to ensure you can troubleshoot issues.
 

Have a backup plan: If uv installation fails for a participant:
    They can pair with someone whose installation worked
    Provide a pre-configured cloud environment (Google Colab, GitHub Codespaces)
    As last resort, have instructions for traditional Python installation
 

Emphasize the "why": 
    "This approach means your project specifies its Python version in .python-version"
    "When collaborators run your project, they get the EXACT same Python"
    "This is reproducible research in practice"
 

Address the mental model shift:
    Some participants may have learned "install Python first"
    Acknowledge this: "If you've used Python before, this might feel backwards. But modern tools like uv make our lives easier by managing Python FOR us."
```